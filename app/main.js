/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/***/ (() => {

eval("const KEYS = 'qasdfghj'.split('');\nconst MUSIC_NOTES_CONFIG = [{\n  keyboardKey: 'a',\n  frequency: 261.63 // C note, on C major scale\n}, {\n  keyboardKey: 's',\n  frequency: 293.66 // D note\n}, {\n  keyboardKey: 'd',\n  frequency: 329.63 // E note\n}, {\n  keyboardKey: 'f',\n  frequency: 349.23 // F note\n}, {\n  keyboardKey: 'g',\n  frequency: 392 // G note\n}, {\n  keyboardKey: 'h',\n  frequency: 440 // A note\n}, {\n  keyboardKey: 'j',\n  frequency: 493.88 // B note\n}];\nconst SFX_CONFIG = [{\n  keyboardKey: 'q',\n  name: 'splash'\n}];\n\n/*\r\nPrimary App Class\r\n */\nclass App {\n  constructor() {\n    console.log('HTML5 Audio Experiment is booting up');\n\n    // General app properties\n    this.audioContext = undefined;\n    this.audioData = undefined;\n\n    // Actively playing sounds\n    this.activeMusicNotes = new Map();\n\n    // Bind functions to self\n    this.app_onKeyDown = this.app_onKeyDown.bind(this);\n    this.app_onKeyUp = this.app_onKeyUp.bind(this);\n    this.musicNotes_onClick = this.musicNotes_onClick.bind(this);\n    this.sfxButton_onClick = this.sfxButton_onClick.bind(this);\n    this.startButton_onClick = this.startButton_onClick.bind(this);\n\n    // Setup initial UI\n    const htmlMain = document.querySelector('main');\n    htmlMain.addEventListener('keydown', this.app_onKeyDown);\n    htmlMain.addEventListener('keyup', this.app_onKeyUp);\n    document.querySelector('#start-button').addEventListener('click', this.startButton_onClick);\n    document.querySelector('#start-button').focus();\n\n    // Only initialise after user input\n    this.initialised = false;\n  }\n\n  /*\r\n  Initialise only after user input.\r\n  AudioContext can't be created until app receives some sort of user input.\r\n   */\n  async initAfterUserInput() {\n    if (this.initialised) return;\n\n    // Remove start button\n    // document.querySelector('#start-button').removeEventListener('click', this.startButton_onClick)  // Is this necessary?\n    document.querySelector('#start-button').remove();\n\n    // Initiate audio system\n    this.audioContext = new AudioContext();\n    await this.loadFiles();\n\n    // Cleanup\n    this.setupUI();\n    this.initialised = true;\n    document.querySelector('main').focus();\n  }\n  setupUI() {\n    // Add SFX buttons\n    const htmlSFXButtonsContainer = document.querySelector('#sfx-buttons');\n    SFX_CONFIG.forEach(sfx => {\n      const htmlLi = document.createElement('li');\n      const htmlButton = document.createElement('button');\n      htmlButton.innerText = `[${sfx.keyboardKey.toUpperCase()}] ${sfx.name}`;\n      htmlButton.dataset.keyboardKey = sfx.keyboardKey;\n      htmlButton.addEventListener('click', this.sfxButton_onClick);\n      htmlLi.appendChild(htmlButton);\n      htmlSFXButtonsContainer.appendChild(htmlLi);\n    });\n\n    // Add musical notes\n    const htmlMusicNotesContainer = document.querySelector('#music-notes');\n    MUSIC_NOTES_CONFIG.forEach(musicNote => {\n      const htmlLi = document.createElement('li');\n      const htmlButton = document.createElement('button');\n      htmlButton.innerText = `[${musicNote.keyboardKey.toUpperCase()}]`;\n      htmlButton.dataset.keyboardKey = musicNote.keyboardKey;\n      htmlButton.addEventListener('click', this.musicNotes_onClick);\n      htmlLi.appendChild(htmlButton);\n      htmlMusicNotesContainer.appendChild(htmlLi);\n    });\n  }\n  async loadFiles() {\n    this.audioData = {\n      splash: await this.fetchAudioData('assets/bbc-splash.wav')\n    };\n  }\n  async fetchAudioData(filepath) {\n    const res = await fetch(filepath);\n    const arrayBuffer = await res.arrayBuffer();\n    const audioData = await this.audioContext.decodeAudioData(arrayBuffer);\n    return audioData;\n  }\n  app_onKeyDown(e) {\n    if (!this.initialised) return;\n    const keyboardKey = e.key.toLowerCase();\n    if (MUSIC_NOTES_CONFIG.find(mn => mn.keyboardKey === keyboardKey)) {\n      this.startPlayingMusicNote(keyboardKey);\n    }\n  }\n  app_onKeyUp(e) {\n    if (!this.initialised) return;\n    const keyboardKey = e.key.toLowerCase();\n    if (MUSIC_NOTES_CONFIG.find(mn => mn.keyboardKey === keyboardKey)) {\n      this.stopPlayingMusicNote(keyboardKey);\n    }\n    SFX_CONFIG.forEach(sfx => {\n      if (sfx.keyboardKey === keyboardKey) {\n        this.playSoundFromAudioData(sfx.name);\n      }\n    });\n  }\n  musicNotes_onClick(e) {\n    const keyboardKey = e.target.dataset.keyboardKey;\n    MUSIC_NOTES_CONFIG.forEach(musicNote => {\n      if (musicNote.keyboardKey === keyboardKey) {\n        this.playSoundFromCode(musicNote.frequency);\n      }\n    });\n  }\n  sfxButton_onClick(e) {\n    const keyboardKey = e.target.dataset.keyboardKey;\n    SFX_CONFIG.forEach(sfx => {\n      if (sfx.keyboardKey === keyboardKey) {\n        this.playSoundFromAudioData(sfx.name);\n      }\n    });\n  }\n  startButton_onClick(e) {\n    this.initAfterUserInput();\n  }\n\n  /*\r\n  Play an instance of a sound from registered audio data.\r\n  For every instance of a sound, create a new AudioBufferSourceNode.\r\n  Each AudioBufferSourceNode can only have .start() called once.\r\n   */\n  playSoundFromAudioData(name) {\n    if (!this.initialised) return;\n    if (!name || !this.audioData?.[name]) {\n      console.error('Can\\'t find audio data for ', name);\n      return;\n    }\n    const audioContext = this.audioContext;\n    const audioSource = audioContext.createBufferSource();\n    audioSource.buffer = this.audioData[name];\n    audioSource.connect(audioContext.destination);\n    audioSource.start();\n  }\n\n  /*\r\n  Play an instance of a basic sound like a beep or a boop.\r\n   */\n  playSoundFromCode(frequencyHz = 440, type = 'sine', duration = 0.2, fadeOutDuration = 0.1) {\n    if (!this.initialised) return;\n    const audioContext = this.audioContext;\n    const t = audioContext.currentTime;\n\n    // Create the sound maker\n    const oscillator = audioContext.createOscillator();\n    oscillator.type = type;\n    oscillator.frequency.setValueAtTime(frequencyHz, t);\n\n    // Use the Gain node to slowly increase, then taper off the sound.\n    // If we didn't do this, we'd sometimes her clicking sounds.\n    const gainNode = audioContext.createGain();\n    gainNode.gain.setValueAtTime(0, t);\n    gainNode.gain.linearRampToValueAtTime(1, t + (duration - fadeOutDuration));\n    // TODO: implement separate fadeInDuration\n    gainNode.gain.linearRampToValueAtTime(0, t + duration);\n\n    // Connect the audio nodes together, and then play\n    oscillator.connect(gainNode).connect(audioContext.destination);\n    oscillator.start(); // Optional: oscillator.start(audioContext.currentTime)\n    oscillator.stop(t + duration);\n  }\n\n  /*\r\n  Start playing an instance of a basic sound like a beep or a boop, but don't\r\n  stop until stopPlayingMusicNote() is called.\r\n  A more advanced version of playSoundFromCode().\r\n   */\n  startPlayingMusicNote(keyboardKey) {\n    if (!this.initialised || !keyboardKey) return;\n    if (this.activeMusicNotes.has(keyboardKey)) return; // Sound is already playing\n\n    // Get sound details\n    const musicNote = MUSIC_NOTES_CONFIG.find(mn => mn.keyboardKey === keyboardKey);\n    if (!musicNote) return;\n\n    // Audio setup\n    const audioContext = this.audioContext;\n    const t = audioContext.currentTime;\n    const fadeInDuration = 0.05;\n    const type = 'sine';\n    const frequencyHz = musicNote.frequency;\n\n    // Create the sound maker\n    const oscillator = audioContext.createOscillator();\n    oscillator.type = type;\n    oscillator.frequency.setValueAtTime(frequencyHz, t);\n\n    // Use the Gain node to slowly increase sound.\n    // If we didn't do this, we'd sometimes her clicking sounds.\n    const gainNode = audioContext.createGain();\n    gainNode.gain.setValueAtTime(0, t);\n    gainNode.gain.linearRampToValueAtTime(1, t + fadeInDuration);\n\n    // Connect the audio nodes together, and then play\n    oscillator.connect(gainNode).connect(audioContext.destination);\n    oscillator.start(); // Optional: oscillator.start(audioContext.currentTime)\n    // oscillator.stop(t + duration)\n\n    // Register actively playing sound\n    this.activeMusicNotes.set(keyboardKey, {\n      oscillator: oscillator,\n      gainNode: gainNode\n    });\n  }\n\n  /*\r\n  Stops playing a sound.\r\n   */\n  stopPlayingMusicNote(keyboardKey) {\n    if (!this.initialised || !keyboardKey) return;\n\n    // Get sound details\n    const musicNote = this.activeMusicNotes.get(keyboardKey);\n    if (!musicNote) return;\n\n    // Audio setup\n    const audioContext = this.audioContext;\n    const t = audioContext.currentTime;\n    const fadeOutDuration = 0.05;\n\n    // Stop the sound.\n    // Use the Gain node to slowly taper off the sound.\n    // If we didn't do this, we'd sometimes her clicking sounds.\n    musicNote.gainNode.gain.setValueAtTime(1, t);\n    musicNote.gainNode.gain.linearRampToValueAtTime(0, t + fadeOutDuration);\n    musicNote.oscillator.stop(t + fadeOutDuration);\n\n    // Unregister actively playing sound\n    this.activeMusicNotes.delete(keyboardKey);\n  }\n}\n\n/*\r\nInitialise!\r\n */\nwindow.onload = function () {\n  window.app = new App();\n};\n\n//# sourceURL=webpack://html5-audio-experiment/./src/main.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/main.js"]();
/******/ 	
/******/ })()
;